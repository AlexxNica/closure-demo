{"version":3,"file":"change_detector_ref.js","sourceRoot":"","sources":["../../../../../modules/@angular/core/src/change_detection/change_detector_ref.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAEH;;GAEG;AACH;IAAA;IA+BA,CAAC;IA9BD;;;;OAIG;IACH,wCAAY,GAAZ,cAAgB,CAAC;IACjB;;;;OAIG;IACH,kCAAM,GAAN,cAAU,CAAC;IACX;;;;OAIG;IACH,yCAAa,GAAb,cAAiB,CAAC;IAClB;;;;OAIG;IACH,0CAAc,GAAd,cAAkB,CAAC;IACnB;;;;OAIG;IACH,oCAAQ,GAAR,cAAY,CAAC;IACb,wBAAC;AAAD,CAAC,AA/BD,IA+BC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @stable\n */\nexport abstract class ChangeDetectorRef {\n/**\n *  Marks all {@link ChangeDetectionStrategy#OnPush} ancestors as to be checked. * <!-- TODO: Add a link to a chapter on OnPush components --> * ### Example ([live demo](http://plnkr.co/edit/GC512b?p=preview)) * ```typescript selector: 'cmp', changeDetection: ChangeDetectionStrategy.OnPush, template: `Number of ticks: {{numberOfTicks}}` }) class Cmp { numberOfTicks = 0; * constructor(ref: ChangeDetectorRef) { setInterval(() => { this.numberOfTicks ++ // the following is required, otherwise the view will not be updated this.ref.markForCheck(); }, 1000); } } * selector: 'app', changeDetection: ChangeDetectionStrategy.OnPush, template: ` <cmp><cmp> `, }) class App { } ```\n * @abstract\n * @return {?}\n */\nmarkForCheck() {}\n/**\n *  Detaches the change detector from the change detector tree. * The detached change detector will not be checked until it is reattached. * This can also be used in combination with {@link ChangeDetectorRef#detectChanges} to implement local change detection checks. * <!-- TODO: Add a link to a chapter on detach/reattach/local digest --> <!-- TODO: Add a live demo once ref.detectChanges is merged into master --> * ### Example * The following example defines a component with a large list of readonly data. Imagine the data changes constantly, many times per second. For performance reasons, we want to check and update the list every five seconds. We can do that by detaching the component's change detector and doing a local check every five seconds. * ```typescript class DataProvider { // in a real application the returned data will be different every time get data() { return [1,2,3,4,5]; } } * selector: 'giant-list', template: ` <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</lig> `, }) class GiantList { constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) { ref.detach(); setInterval(() => { this.ref.detectChanges(); }, 5000); } } * selector: 'app', providers: [DataProvider], template: ` <giant-list><giant-list> `, }) class App { } ```\n * @abstract\n * @return {?}\n */\ndetach() {}\n/**\n *  Checks the change detector and its children. * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement local change detection checks. * <!-- TODO: Add a link to a chapter on detach/reattach/local digest --> <!-- TODO: Add a live demo once ref.detectChanges is merged into master --> * ### Example * The following example defines a component with a large list of readonly data. Imagine, the data changes constantly, many times per second. For performance reasons, we want to check and update the list every five seconds. * We can do that by detaching the component's change detector and doing a local change detection check every five seconds. * See {@link ChangeDetectorRef#detach} for more information.\n * @abstract\n * @return {?}\n */\ndetectChanges() {}\n/**\n *  Checks the change detector and its children, and throws if any changes are detected. * This is used in development mode to verify that running change detection doesn't introduce other changes.\n * @abstract\n * @return {?}\n */\ncheckNoChanges() {}\n/**\n *  Reattach the change detector to the change detector tree. * This also marks OnPush ancestors as to be checked. This reattached change detector will be checked during the next change detection run. * <!-- TODO: Add a link to a chapter on detach/reattach/local digest --> * ### Example ([live demo](http://plnkr.co/edit/aUhZha?p=preview)) * The following example creates a component displaying `live` data. The component will detach its change detector from the main change detector tree when the component's live property is set to false. * ```typescript class DataProvider { data = 1; * constructor() { setInterval(() => { this.data = this.data * 2; }, 500); } } * selector: 'live-data', inputs: ['live'], template: 'Data: {{dataProvider.data}}' }) class LiveData { constructor(private ref: ChangeDetectorRef, private dataProvider:DataProvider) {} * set live(value) { if (value) this.ref.reattach(); else this.ref.detach(); } } * selector: 'app', providers: [DataProvider], template: ` Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\"> <live-data [live]=\"live\"><live-data> `, }) class App { live = true; } ```\n * @abstract\n * @return {?}\n */\nreattach() {}\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}